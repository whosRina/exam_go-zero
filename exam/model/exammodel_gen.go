// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.7.2

package model

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	jx "github.com/jmoiron/sqlx"
	"github.com/zeromicro/go-zero/core/logx"
	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
	"strings"
	"time"
)

var (
	examFieldNames          = builder.RawFieldNames(&Exam{})
	examRows                = strings.Join(examFieldNames, ",")
	examRowsExpectAutoSet   = strings.Join(stringx.Remove(examFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	examRowsWithPlaceHolder = strings.Join(stringx.Remove(examFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"
)

type (
	examModel interface {
		Insert(ctx context.Context, data *Exam) (sql.Result, error)
		FindOne(ctx context.Context, id int64) (*Exam, error)
		Update(ctx context.Context, data *Exam) error
		Delete(ctx context.Context, id int64) error
		FindByTeacherId(ctx context.Context, teacherId int64) ([]*Exam, error)
		FindByClassIds(ctx context.Context, classIds []int64) ([]*Exam, error)
	}

	defaultExamModel struct {
		conn  sqlx.SqlConn
		table string
	}

	Exam struct {
		Id                    int64     `db:"id"`                      // 考试ID
		Name                  string    `db:"name"`                    // 考试名称
		TeacherId             int64     `db:"teacher_id"`              // 发布考试的教师ID
		ClassId               int64     `db:"class_id"`                // 关联班级ID
		ExamType              string    `db:"exam_type"`               // 试题生成方式（固定or随机）
		TotalScore            int64     `db:"total_score"`             // 总分
		RequiresManualGrading bool      `db:"requires_manual_grading"` // 是否包含需要人工阅卷的题目
		StartTime             time.Time `db:"start_time"`              // 考试开始时间
		EndTime               time.Time `db:"end_time"`                // 考试结束时间
		PaperId               int64     `db:"paper_id"`                // 固定试卷ID，exam_type=fixed时使用
		PaperRuleId           int64     `db:"paper_rule_id"`           // 随机试卷生成规则ID，exam_type=random时使用
		CanViewResults        bool      `db:"can_view_results"`        // 考试结束后是否公开试题
		CreatedAt             time.Time `db:"created_at"`              // 创建时间
	}
)

func newExamModel(conn sqlx.SqlConn) *defaultExamModel {
	return &defaultExamModel{
		conn:  conn,
		table: "`exam`",
	}
}

func (m *defaultExamModel) Delete(ctx context.Context, id int64) error {
	query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
	_, err := m.conn.ExecCtx(ctx, query, id)
	return err
}

func (m *defaultExamModel) FindOne(ctx context.Context, id int64) (*Exam, error) {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", examRows, m.table)
	var resp Exam
	err := m.conn.QueryRowCtx(ctx, &resp, query, id)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultExamModel) Insert(ctx context.Context, data *Exam) (sql.Result, error) {
	query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, examRowsExpectAutoSet)
	ret, err := m.conn.ExecCtx(ctx, query, data.Name, data.TeacherId, data.ClassId, data.ExamType, data.TotalScore, data.RequiresManualGrading, data.StartTime, data.EndTime, data.PaperId, data.PaperRuleId, data.CanViewResults)
	return ret, err
}

func (m *defaultExamModel) Update(ctx context.Context, data *Exam) error {
	query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, examRowsWithPlaceHolder)
	_, err := m.conn.ExecCtx(ctx, query, data.Name, data.TeacherId, data.ClassId, data.ExamType, data.TotalScore, data.RequiresManualGrading, data.StartTime, data.EndTime, data.PaperId, data.PaperRuleId, data.CanViewResults, data.Id)
	return err
}

func (m *defaultExamModel) tableName() string {
	return m.table
}

func (m *defaultExamModel) FindByTeacherId(ctx context.Context, teacherId int64) ([]*Exam, error) {
	query := fmt.Sprintf(`
		SELECT %s 
		FROM %s 
		WHERE teacher_id = ? 
		ORDER BY start_time DESC`,
		examRows, m.table)
	var exams []*Exam
	err := m.conn.QueryRowsCtx(ctx, &exams, query, teacherId)
	switch err {
	case nil:
		return exams, nil
	case sqlx.ErrNotFound:
		return []*Exam{}, nil
	default:
		return nil, err
	}
}

func (m *defaultExamModel) FindByClassIds(ctx context.Context, classIds []int64) ([]*Exam, error) {
	// 如果班级列表为空，直接返回空切片
	if len(classIds) == 0 {
		return []*Exam{}, nil
	}
	query, args, err := jx.In(fmt.Sprintf(`
        SELECT %s 
        FROM %s 
        WHERE class_id IN (?)
        ORDER BY start_time DESC`,
		examRows, m.table), classIds)
	if err != nil {
		logx.Errorf("构建查询语句失败: %v", err)
		return nil, errors.New("构建查询失败")
	}
	var exams []*Exam
	err = m.conn.QueryRowsCtx(ctx, &exams, query, args...)
	switch err {
	case nil:
		return exams, nil
	case sqlx.ErrNotFound:
		return []*Exam{}, nil
	default:
		logx.Errorf("查询考试列表失败: %v", err)
		return nil, err
	}
}
